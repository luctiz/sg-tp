<!doctype html>
<html>
    <head>
        <title></title>        
        <style>
            body{ background-color: grey; }
            canvas{ background-color: rgb(100,100,100); }
			textarea{ background-color: black; foreground-color: white;}
        </style>
    </head>
    <body>

    	<center>    		            
            <canvas id="my-canvas" width="1000" height="800">
            	Your browser does not support the HTML5 canvas element.
    		</canvas>    		
    	</center>

        <script type="text/javascript" src="js/gl-matrix.js"></script>
        <script type="text/javascript" src="js/objeto3D.js"></script>
        <script type="text/javascript" src="js/moduloGeometria.js"></script>
        <script type="text/javascript" src="droneCamera.js"></script>

        
        <script id="shader-vs" type="x-shader/x-vertex">

            precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;

            uniform mat4 modelMatrix;            
            uniform mat4 viewMatrix;
            uniform mat4 projMatrix;

            uniform mat4 normalMatrix;

            varying vec3 vNormal;    
            varying vec3 vPosWorld;  

            void main(void) {
                gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(aVertexPosition, 1.0);

                vPosWorld=(modelMatrix*vec4(aVertexPosition,1.0)).xyz;    //la posicion en coordenadas de mundo
                vNormal=(normalMatrix*vec4(aVertexNormal,1.0)).xyz;       //la normal en coordenadas de mundo                
                
            }
        </script>

        <script id="shader-fs" type="x-shader/x-fragment">
            precision highp float;
            uniform vec3 difuseColor;
            varying vec3 vNormal;
            varying vec3 vPosWorld;

            void main(void) {

                vec3 lightVec=normalize(vec3(0.0,3.0,5.0)-vPosWorld);
                vec3 diffColor=mix(vec3(0.7,0.7,0.7),vNormal,0.4);
                vec3 color= dot(lightVec, vNormal) * difuseColor ;

               gl_FragColor = vec4(color,1.0);
            }
        </script>
        
        <script>
            function Esfera(radio){

                this.getPosicion=function(u,v){
                    var tita = v*Math.PI;
                    var fi = u*Math.PI*2
                    var x = radio*Math.sin(tita)*Math.cos(fi)
                    var y = radio*Math.sin(tita)*Math.sin(fi)
                    var z = radio*Math.cos(tita)
                    return [x,y,z];
                }

                this.getNormal=function(u,v){
                    var delta=0.01;
                    var p0=this.getPosicion(u,v);
                    var p1=this.getPosicion(u,v+delta); // tener cuidado si u o v son mayores que 1. En esfera no pasa nada
                    var p2=this.getPosicion(u+delta,v);

                    
                    var v1=vec3.fromValues(p1[0]-p0[0],p1[1]-p0[1],p1[2]-p0[2]);
                    var v2=vec3.fromValues(p2[0]-p0[0],p2[1]-p0[1],p2[2]-p0[2]);

                    vec3.normalize(v1,v1);
                    vec3.normalize(v2,v2);
                    
                    var n=vec3.create();
                    vec3.cross(n,v1,v2);
                    vec3.scale(n,n,-1);
                    
                    return n                }

                this.getCoordenadasTextura=function(u,v){
                    return [u,v];
                }
            }

            function EsferaRara(radio){
                this.getPosicion= function(u,v){
                    var alfa=v*Math.PI*2;
                    var beta=(0.1+u*0.8)*Math.PI;
                    var r=radio;
                    var nx=Math.sin(beta)*Math.sin(alfa);
                    var ny=Math.sin(beta)*Math.cos(alfa);
                    var nz=Math.cos(beta);


                    var g=beta%0.5;
                    var h=alfa%1;
                    var f=1;

                    if (g<0.25) f=0.95;
                    if (h<0.5) f=f*0.95;

                    var x=nx*r*f;
                    var y=ny*r*f;
                    var z=nz*r*f;

                    return [x,y,z];
                }

                this.getNormal=function(u,v){
                    var delta=0.016;
                    var p1=this.getPosicion(u,v);
                    var p2=this.getPosicion(u,v+delta);
                    var p3=this.getPosicion(u+delta,v);

                    var v1=vec3.fromValues(p2[0]-p1[0],p2[1]-p1[1],p2[2]-p1[2]);
                    var v2=vec3.fromValues(p3[0]-p1[0],p3[1]-p1[1],p3[2]-p1[2]);

                    vec3.normalize(v1,v1);
                    vec3.normalize(v2,v2);
                    
                    var n=vec3.create();
                    vec3.cross(n,v1,v2);
                    vec3.normalize(n,n)
                    return n;
                }

                this.getCoordenadasTextura=function(u,v){
                    return [u,v];
                }
            }

            function CurvaBezier(poligono_control){
                function fact(num)
                {
                    var rval=1;
                    for (var i = 2; i <= num; i++)
                        rval = rval * i;
                    return rval;
                }

                function combinations(n,k) {

                    return (fact(n) / ((fact(k)) * fact(n - k)))
                }

                function B(i,n,t) {
                    /*if ((i == 0) &(t==0)){
                        return (combinations(n,i)*((1-t)**(n-i)) *1)
                    } else if (t==1){
                        return (combinations(n,i)*(1) *(t**i))
                    }*/
                    return (combinations(n,i)*((1-t)**(n-i)) *(t**i))
                }

                this.evaluarPunto= function(t){
                    resultado = vec3.fromValues(0,0,0);
                    n = poligono_control.length;
                    for (i = 0; i< n; i++){
                        var auxvec = vec3.create();
                        vec3.scale(auxvec,poligono_control[i],B(i,n-1,t));

                        vec3.add(resultado,resultado, auxvec);
                    }
                    return resultado;
                }

            }

            
            // crea una circunferencia en el plano xy rotada segun vec_rot
            function CurvaCircunferencia(radio, vec_rot){
                this.evaluarPunto= function(t){

                    position = vec3.fromValues(Math.cos(Math.PI*2*t),Math.sin(Math.PI*2*t),0)
                    vec3.scale(position, position, radio)
                    vec3.rotateX(position, position, vec3.fromValues(0,0,0), vec_rot[0])
                    vec3.rotateY(position, position, vec3.fromValues(0,0,0), vec_rot[1])
                    vec3.rotateZ(position, position, vec3.fromValues(0,0,0), vec_rot[2])

                    return position;
                }
            }

            

            function obtenerDiscretizacionCurva(curva, cantidad_puntos_a_discretizar){
                position_list = []
                tang_list = []
                
                let auxn = (cantidad_puntos_a_discretizar -1)
                for (let i = 0; i <= auxn; i++){
                    punto = curva.evaluarPunto(i/auxn)
                    position_list.push(punto[0])
                    position_list.push(punto[1])
                    position_list.push(punto[2])

                    if (i == 0){
                        p0 = punto;
                    } else {
                        p0 = curva.evaluarPunto((i-0.01)/auxn);
                    }
                    if (i == 1){
                        p1 = punto
                    } else {
                        p1 = curva.evaluarPunto((i+0.01)/auxn)
                    }
                    tang_vec = vec3.create()
                    vec3.sub(tang_vec,p1,p0)  
                    vec3.normalize(tang_vec,tang_vec)
                    tang_list.push(tang_vec[0])
                    tang_list.push(tang_vec[1])
                    tang_list.push(tang_vec[2])
                }

                return {position_list, tang_list}
            }


            
            var mat4=glMatrix.mat4;
            var vec3=glMatrix.vec3;

            var gl = null,
            canvas = null,

            glProgram = null,
            fragmentShader = null,
            vertexShader = null;
                
            var vertexPositionAttribute = null,
            trianglesVerticeBuffer = null,
            vertexNormalAttribute = null,
            trianglesNormalBuffer = null,
            trianglesIndexBuffer = null;
               
            var modelMatrix = mat4.create();
            var viewMatrix = mat4.create();
            var projMatrix = mat4.create();
            var normalMatrix = mat4.create();
            var rotate_angle = -1.57078;
            
            let droneCam=new DroneCameraControl([0,0,6]);

         
            function initWebGL(){

                canvas = document.getElementById("my-canvas");  

                try{
                    gl = canvas.getContext("webgl");      

                }catch(e){
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

                if(gl) {

                    setupWebGL();
                    initShaders();
                    esferaRara = new Esfera(4);
                    objeto = new Objeto3D()

                    geometria = ModuloGeometria.obtenerGeometriaObjeto3D(esferaRara,100,100)
                    objeto.setGeometria(geometria.vertexBuffer, geometria.indexBuffer)
                    objeto.setPosicion(0,10,0);
                    objeto.setColor(0,1,0);

                    poligono_control=[vec3.fromValues(1,0,0), vec3.fromValues(0,3,0), vec3.fromValues(-1,0,0)]
                    curva_forma = new CurvaCircunferencia(1,[0,0,1.57]);


                    poligono_control=[vec3.fromValues(0,0,8),vec3.fromValues(0,8,0),vec3.fromValues(0,0,-8)]
                    curva_recorrido = new CurvaCircunferencia(5,[0,0,0])//new CurvaBezier(poligono_control);//

                    discretizacion_forma = obtenerDiscretizacionCurva(curva_forma, 15)
                    discretizacion_recorrido = obtenerDiscretizacionCurva(curva_recorrido, 15)

                    
//new CurvaBezier(poligono_control)//
                    objeto_forma = new ObjetoCurva3D();
                    geometria = ModuloGeometria.obtenerGeometriaCurva3D(curva_forma, 15)
                    objeto_forma.setGeometria(geometria.vertexBuffer, geometria.indexBuffer)
                    objeto_forma.setColor(1,0,0)
                    objeto_forma.setPosicion(0,-10,0)

                    //
                    objeto_tangentes_forma = new ObjetoCurva3D();
                    geometria = ModuloGeometria.obtenerGeometriaTangentesCurva3D(discretizacion_forma);
                    objeto_tangentes_forma.setGeometria(geometria.vertexBuffer, geometria.indexBuffer)
                    objeto_tangentes_forma.setColor(1,0,0)
                    objeto_forma.agregarHijo(objeto_tangentes_forma)
                    //
                    

                    objeto_recorrido = new ObjetoCurva3D();
                    geometria = ModuloGeometria.obtenerGeometriaCurva3D(curva_recorrido, 15)
                    objeto_recorrido.setGeometria(geometria.vertexBuffer, geometria.indexBuffer)
                    objeto_recorrido.setColor(0,1,0)


                    //
                    objeto_tangentes_recorrido = new ObjetoCurva3D();
                    geometria = ModuloGeometria.obtenerGeometriaTangentesCurva3D(discretizacion_recorrido);
                    objeto_tangentes_recorrido.setGeometria(geometria.vertexBuffer, geometria.indexBuffer)
                    objeto_tangentes_recorrido.setColor(0.5,1,0.5)
                    objeto_recorrido.agregarHijo(objeto_tangentes_recorrido)
                    //

                    objeto_forma.agregarHijo(objeto_recorrido)

                    objeto.agregarHijo(objeto_forma)


                    superficie_barrido = new Objeto3D()
                    geometria = ModuloGeometria.obtenerGeometriaSuperficieBarrido(discretizacion_forma, discretizacion_recorrido)
                    superficie_barrido.setGeometria(geometria.vertexBuffer, geometria.indexBuffer)
                    superficie_barrido.setColor(0,1,1)
                    superficie_barrido.setPosicion(0,-10,0)


                    normales_sup_barrido = new ObjetoCurva3D()
                    normales_sup_barrido.setGeometria(geometria.normalVertexBuffer, geometria.normalIndexBuffer)
                    normales_sup_barrido.setColor(1,1,1)
                    superficie_barrido.agregarHijo(normales_sup_barrido)
                    objeto.agregarHijo(superficie_barrido)

                    
                    setupVertexShaderMatrix();
                    tick();   

                }else{    
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

            }
           

            function setupWebGL(){
                gl.enable(gl.DEPTH_TEST);
                //set the clear color
                gl.clearColor(0.1, 0.1, 0.2, 1.0);     
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);     
    
                gl.viewport(0, 0, canvas.width, canvas.height);

                // Matrix de Proyeccion Perspectiva

                mat4.perspective(projMatrix,45, canvas.width / canvas.height, 0.1, 100.0);
                
                mat4.identity(modelMatrix);
                mat4.rotate(modelMatrix,modelMatrix, -1.57078, [1.0, 0.0, 0.0]);

                mat4.identity(viewMatrix);
                mat4.translate(viewMatrix,viewMatrix, [0.0, 0.0, -5.0]);
            }
                    
                    
            function initShaders() {
                //get shader source
                var fs_source = document.getElementById('shader-fs').innerHTML,
                    vs_source = document.getElementById('shader-vs').innerHTML;

                //compile shaders    
                vertexShader = makeShader(vs_source, gl.VERTEX_SHADER);
                fragmentShader = makeShader(fs_source, gl.FRAGMENT_SHADER);
                
                //create program
                glProgram = gl.createProgram();
                
                //attach and link shaders to the program
                gl.attachShader(glProgram, vertexShader);
                gl.attachShader(glProgram, fragmentShader);
                gl.linkProgram(glProgram);

                if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
                    alert("Unable to initialize the shader program.");
                }
                
                //use program
                gl.useProgram(glProgram);
            }
            
            function makeShader(src, type){
                //compile the vertex shader
                var shader = gl.createShader(type);
                gl.shaderSource(shader, src);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.log("Error compiling shader: " + gl.getShaderInfoLog(shader));
                }
                return shader;
            }


            function setupVertexShaderMatrix(){
                var viewMatrixUniform  = gl.getUniformLocation(glProgram, "viewMatrix");
                var projMatrixUniform  = gl.getUniformLocation(glProgram, "projMatrix");
                var normalMatrixUniform  = gl.getUniformLocation(glProgram, "normalMatrix");

                gl.uniformMatrix4fv(viewMatrixUniform, false, viewMatrix);
                gl.uniformMatrix4fv(projMatrixUniform, false, projMatrix);
                gl.uniformMatrix4fv(normalMatrixUniform, false, normalMatrix);
            }      
            
            function drawScene(){
                setupVertexShaderMatrix();
                matPadre= mat4.create() // matriz identidad para objeto principal

                objeto.dibujar(matPadre);                
            }
            
            
            function tick(){
                viewMatrix=droneCam.getViewMatrix();

                requestAnimationFrame(tick);
                droneCam.update();
                drawScene();
                //objeto.animate();
            }

            window.onload=initWebGL;

        </script>


    </body>
</html>
