<!doctype html>
<html>
    <head>
        <title></title>        
        <style>
            body{ background-color: grey; }
            canvas{ background-color: darkslategrey; }
			textarea{ background-color: black; foreground-color: white;}
        </style>
    </head>
    <body>

    	<center>    		            
            <canvas id="my-canvas" width="1000" height="800">
            	Your browser does not support the HTML5 canvas element.
    		</canvas>    		
    	</center>

        <script type="text/javascript" src="js/gl-matrix.js"></script>
        <script type="text/javascript" src="js/objeto3D.js"></script>
        <script type="text/javascript" src="droneCamera.js"></script>

        
        <script id="shader-vs" type="x-shader/x-vertex">

            precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;

            uniform mat4 modelMatrix;            
            uniform mat4 viewMatrix;
            uniform mat4 projMatrix;

            uniform mat4 normalMatrix;

            varying vec3 vNormal;    
            varying vec3 vPosWorld;  

            void main(void) {
                gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(aVertexPosition, 1.0);

                vPosWorld=(modelMatrix*vec4(aVertexPosition,1.0)).xyz;    //la posicion en coordenadas de mundo
                vNormal=(normalMatrix*vec4(aVertexNormal,1.0)).xyz;       //la normal en coordenadas de mundo                
                
            }
        </script>

        <script id="shader-fs" type="x-shader/x-fragment">
            precision highp float;
            uniform vec3 difuseColor;
            varying vec3 vNormal;
            varying vec3 vPosWorld;

            void main(void) {

                vec3 lightVec=normalize(vec3(0.0,3.0,5.0)-vPosWorld);
                vec3 diffColor=mix(vec3(0.7,0.7,0.7),vNormal,0.4);
                vec3 color= dot(lightVec, vNormal) * difuseColor ;

               gl_FragColor = vec4(color,1.0);
            }
        </script>
        
        <script>
            function Esfera(radio){

                this.getPosicion=function(u,v){
                    var tita = v*Math.PI;
                    var fi = u*Math.PI*2
                    var x = radio*Math.sin(tita)*Math.cos(fi)
                    var y = radio*Math.sin(tita)*Math.sin(fi)
                    var z = radio*Math.cos(tita)
                    return [x,y,z];
                }

                this.getNormal=function(u,v){
                    var delta=0.01;
                    var p0=this.getPosicion(u,v);
                    var p1=this.getPosicion(u,v+delta); // tener cuidado si u o v son mayores que 1. En esfera no pasa nada
                    var p2=this.getPosicion(u+delta,v);
                    
                    //var normal = crossProduct(vectorSubstract(p1,p0),vectorSubstract(p2,p0));
                    //var normal_normalizada = Math.sqrt(normal[0]**2 + normal[1]**2 + normal[2]**2)

                    
                    var v1=vec3.fromValues(p1[0]-p0[0],p1[1]-p0[1],p1[2]-p0[2]);
                    var v2=vec3.fromValues(p2[0]-p0[0],p2[1]-p0[1],p2[2]-p0[2]);

                    vec3.normalize(v1,v1);
                    vec3.normalize(v2,v2);
                    
                    var n=vec3.create();
                    vec3.cross(n,v1,v2);
                    vec3.scale(n,n,-1);
                    
                    return n
                    //return normal_normalizada;
                }

                this.getCoordenadasTextura=function(u,v){
                    return [u,v];
                }
            }

            function EsferaRara(radio){
                this.getPosicion= function(u,v){
                    var alfa=v*Math.PI*2;
                    var beta=(0.1+u*0.8)*Math.PI;
                    var r=radio;
                    var nx=Math.sin(beta)*Math.sin(alfa);
                    var ny=Math.sin(beta)*Math.cos(alfa);
                    var nz=Math.cos(beta);


                    var g=beta%0.5;
                    var h=alfa%1;
                    var f=1;

                    if (g<0.25) f=0.95;
                    if (h<0.5) f=f*0.95;

                    var x=nx*r*f;
                    var y=ny*r*f;
                    var z=nz*r*f;

                    return [x,y,z];
                }

                this.getNormal=function(u,v){
                    //var p=this.getPosicion(u,v);
                    //var vec=vec3.create();
                    //vec3.normalize(vec,p);

                    var delta=0.016;
                    var p1=this.getPosicion(u,v);
                    var p2=this.getPosicion(u,v+delta);
                    var p3=this.getPosicion(u+delta,v);

                    var v1=vec3.fromValues(p2[0]-p1[0],p2[1]-p1[1],p2[2]-p1[2]);
                    var v2=vec3.fromValues(p3[0]-p1[0],p3[1]-p1[1],p3[2]-p1[2]);

                    vec3.normalize(v1,v1);
                    vec3.normalize(v2,v2);
                    
                    var n=vec3.create();
                    vec3.cross(n,v1,v2);
                    //vec3.normalize(n,n)
                    //vec3.scale(n,n,-1);
                    return n;
                }

                this.getCoordenadasTextura=function(u,v){
                    return [u,v];
                }
            }

            function CurvaBezier(poligono_control){
                function fact(num)
                {
                    var rval=1;
                    for (var i = 2; i <= num; i++)
                        rval = rval * i;
                    return rval;
                }

                function combinations(n,k) {

                    return (fact(n) / ((fact(k)) * fact(n - k)))
                }

                function B(i,n,t) {
                    /*if ((i == 0) &(t==0)){
                        return (combinations(n,i)*((1-t)**(n-i)) *1)
                    } else if (t==1){
                        return (combinations(n,i)*(1) *(t**i))
                    }*/
                    return (combinations(n,i)*((1-t)**(n-i)) *(t**i))
                }

                this.evaluarPunto= function(t){
                    resultado = vec3.fromValues(0,0,0);
                    n = poligono_control.length;
                    for (i = 0; i< n; i++){
                        console.log(`B(${i},${n-1},${t}) = ${B(i,n-1,t)}`)
                        var auxvec = vec3.create();
                        vec3.scale(auxvec,poligono_control[i],B(i,n-1,t));

                        vec3.add(resultado,resultado, auxvec);
                    }
                    console.log(resultado);
                    return resultado;
                }

            }

            

            function obtenerDiscretizacionCurva(curva, cantidad_puntos_a_discretizar){
                position_list = []
                normal_list = []
                
                let auxn = (cantidad_puntos_a_discretizar -1)
                for (let i = 0; i <= auxn; i++){
                    punto = curva.evaluarPunto(i/auxn)
                    position_list.push(punto[0])
                    position_list.push(punto[1])
                    position_list.push(punto[2])

                    if (i == 0){
                        p0 = punto;
                    } else {
                        p0 = curva.evaluarPunto(i-0.01/auxn);
                    }
                    if (i == 1){
                        p1 = punto
                    } else {
                        p1 = curva.evaluarPunto(i+0.01/auxn)
                    }
                    tang_vec = vec3.create() // el vector tangente creo que estÃ¡ mal
                    vec3.sub(tang_vec,p0,p1)  
                    vec3.normalize(tang_vec,tang_vec)
                    normal_list.push(tang_vec[0])
                    normal_list.push(tang_vec[1])
                    normal_list.push(tang_vec[2])
                }

                return {position_list, normal_list}
            }

            var mat4=glMatrix.mat4;
            var vec3=glMatrix.vec3;

            var gl = null,
            canvas = null,

            glProgram = null,
            fragmentShader = null,
            vertexShader = null;
                
            var vertexPositionAttribute = null,
            trianglesVerticeBuffer = null,
            vertexNormalAttribute = null,
            trianglesNormalBuffer = null,
            trianglesIndexBuffer = null;
               
            var modelMatrix = mat4.create();
            var viewMatrix = mat4.create();
            var projMatrix = mat4.create();
            var normalMatrix = mat4.create();
            var rotate_angle = -1.57078;
            
            let droneCam=new DroneCameraControl([0,0,10]);

         
            function initWebGL(){

                canvas = document.getElementById("my-canvas");  

                try{
                    gl = canvas.getContext("webgl");      

                }catch(e){
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

                if(gl) {

                    setupWebGL();
                    initShaders();
                    esferaRara = new EsferaRara(4);
                    objeto = new Objeto3D()
                    var rows=100;
                    var cols=100;
                    esferaRvertexBuffer = getVertexBuffer(esferaRara, rows, cols);
                    esferaRindexBuffer = getIndexBuffer(rows, cols);
                    objeto.setGeometria(esferaRvertexBuffer, esferaRindexBuffer)
                    objeto.setPosicion(10,0,0);
                    objeto.setRotacion(Math.PI/2,0,0);
                    objeto.setEscala(1,1,1);
                    objeto.setColor(0,1,0);


                    esfera = new Esfera(1);
                    objetoEsfera = new Objeto3D();
                    esferaVertexBuffer = getVertexBuffer(esfera, 20, 20);
                    esferaIndexBuffer = getIndexBuffer(20,20);
                    objetoEsfera.setGeometria(esferaVertexBuffer, esferaIndexBuffer)

                    objetoEsfera.setPosicion(3,3,3);
                    objetoEsfera.setRotacion(1,1,1);
                    objetoEsfera.setEscala(1,1,1);
                    objetoEsfera.setColor(0,0,1);
                    objeto.agregarHijo(objetoEsfera);


                    poligono_control=[vec3.fromValues(3,0,0), vec3.fromValues(0,3,0), vec3.fromValues(-3,0,0), vec3.fromValues(0,-3,0)]
                    curva = new CurvaBezier(poligono_control);

                    var cant_puntos = 20;
                    discretizacion = obtenerDiscretizacionCurva(curva,cant_puntos)

                    curva_secuencia = discretizacion.position_list
                    normal_secuencia = discretizacion.normal_list

                    curve_index=[]

                    curve_index.push(0)
                    for (i = 1; i < cant_puntos -1; i++){
                        curve_index.push(i)
                        curve_index.push(i)
                    }
                    curve_index.push(cant_puntos-1)

                    curve_position_buffer = gl.createBuffer();
                    curve_position_buffer.itemSize = cant_puntos;
                    gl.bindBuffer(gl.ARRAY_BUFFER, curve_position_buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(curva_secuencia), gl.STATIC_DRAW);

                    curve_normal_buffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, curve_normal_buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normal_secuencia), gl.STATIC_DRAW);
                    curve_normal_buffer.itemSize = cant_puntos;

                    curve_index_buffer = gl.createBuffer();
                    curve_index_buffer.itemSize = 1;
                    curve_index_buffer.numItems = curve_index.length;
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, curve_index_buffer);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(curve_index), gl.STATIC_DRAW); 

                    webgl_position_buffer = curve_position_buffer
                    webgl_normal_buffer = curve_normal_buffer
                    
                    setupVertexShaderMatrix();
                    tick();   

                }else{    
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

            }
           

            function setupWebGL(){
                gl.enable(gl.DEPTH_TEST);
                //set the clear color
                gl.clearColor(0.1, 0.1, 0.2, 1.0);     
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);     
    
                gl.viewport(0, 0, canvas.width, canvas.height);

                // Matrix de Proyeccion Perspectiva

                mat4.perspective(projMatrix,45, canvas.width / canvas.height, 0.1, 100.0);
                
                mat4.identity(modelMatrix);
                mat4.rotate(modelMatrix,modelMatrix, -1.57078, [1.0, 0.0, 0.0]);

                mat4.identity(viewMatrix);
                mat4.translate(viewMatrix,viewMatrix, [0.0, 0.0, -5.0]);
            }
                    
                    
            function initShaders() {
                //get shader source
                var fs_source = document.getElementById('shader-fs').innerHTML,
                    vs_source = document.getElementById('shader-vs').innerHTML;

                //compile shaders    
                vertexShader = makeShader(vs_source, gl.VERTEX_SHADER);
                fragmentShader = makeShader(fs_source, gl.FRAGMENT_SHADER);
                
                //create program
                glProgram = gl.createProgram();
                
                //attach and link shaders to the program
                gl.attachShader(glProgram, vertexShader);
                gl.attachShader(glProgram, fragmentShader);
                gl.linkProgram(glProgram);

                if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
                    alert("Unable to initialize the shader program.");
                }
                
                //use program
                gl.useProgram(glProgram);
            }
            
            function makeShader(src, type){
                //compile the vertex shader
                var shader = gl.createShader(type);
                gl.shaderSource(shader, src);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.log("Error compiling shader: " + gl.getShaderInfoLog(shader));
                }
                return shader;
            }


            function getVertexBuffer(superficie, rows,cols)
            {
                var pos=[];
                var uv = [];
                var normal=[];

                for (var i=0;i<rows;i++){
                    for (var j=0;j<cols;j++){

                        var u=i/(rows-1); //esto capaz se tenga que cambiar despues (creo que los nombres u y v no son representativos)
                        var v=j/(cols-1); //Ademas en mi tp de grillas esto lo tenia un poco distinto, no se si va a estar del todo bien

                        var p=superficie.getPosicion(u,v);

                        pos.push(p[0]);
                        pos.push(p[1]);
                        pos.push(p[2]);
                        
                        var n=superficie.getNormal(u,v);

                        normal.push(n[0]);
                        normal.push(n[1]);
                        normal.push(n[2]);

                        var uvs=superficie.getCoordenadasTextura(u,v);

                        uv.push(uvs[0])
                        uv.push(uvs[1])
                    }

                }
                webgl_position_buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, webgl_position_buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos), gl.STATIC_DRAW);
                webgl_position_buffer.itemSize = 3;
                webgl_position_buffer.numItems = pos.length / 3;

                webgl_uvs_buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, webgl_uvs_buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uv), gl.STATIC_DRAW);
                webgl_uvs_buffer.itemSize = 2;
                webgl_uvs_buffer.numItems = uv.length / 2;
            

                webgl_normal_buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, webgl_normal_buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normal), gl.STATIC_DRAW);
                webgl_normal_buffer.itemSize = 3;
                webgl_normal_buffer.numItems = normal.length / 3;
                
                return {
                    webgl_position_buffer,
                    webgl_normal_buffer,
                    webgl_uvs_buffer
                }
            }
            function getIndexBuffer(rows,cols){
                var index=[];

                    for (var i=0;i<rows-1;i++){
                        index.push(i*cols);
                        for (var j=0;j<cols-1;j++){
                            index.push(i*cols+j);
                            index.push((i+1)*cols+j);
                            index.push(i*cols+j+1);
                            index.push((i+1)*cols+j+1);
                        }
                        index.push((i+1)*cols+cols-1);
                    }
                    
                    webgl_index_buffer = gl.createBuffer();
                    webgl_index_buffer.itemSize = 1;
                    webgl_index_buffer.numItems = index.length;
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webgl_index_buffer);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(index), gl.STATIC_DRAW);  
                    return webgl_index_buffer;
            }

            function setupVertexShaderMatrix(){
                var viewMatrixUniform  = gl.getUniformLocation(glProgram, "viewMatrix");
                var projMatrixUniform  = gl.getUniformLocation(glProgram, "projMatrix");
                var normalMatrixUniform  = gl.getUniformLocation(glProgram, "normalMatrix");

                gl.uniformMatrix4fv(viewMatrixUniform, false, viewMatrix);
                gl.uniformMatrix4fv(projMatrixUniform, false, projMatrix);
                gl.uniformMatrix4fv(normalMatrixUniform, false, normalMatrix);
            }                  
            
            function drawScene(){
                setupVertexShaderMatrix();
                matPadre= mat4.create() // matriz identidad para objeto principal

                objeto.dibujar(matPadre);


                var m = mat4.create();

                var modelMatrixUniform = gl.getUniformLocation(glProgram, "modelMatrix");
                gl.uniformMatrix4fv(modelMatrixUniform, false, m);

                vertexPositionAttribute = gl.getAttribLocation(glProgram, "aVertexPosition");
                gl.enableVertexAttribArray(vertexPositionAttribute);
                gl.bindBuffer(gl.ARRAY_BUFFER, curve_position_buffer);
                gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

                vertexNormalAttribute = gl.getAttribLocation(glProgram, "aVertexNormal");
                gl.enableVertexAttribArray(vertexNormalAttribute);
                gl.bindBuffer(gl.ARRAY_BUFFER, curve_normal_buffer);
                gl.vertexAttribPointer(vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, curve_index_buffer);

                difuseColorUniform = gl.getUniformLocation(glProgram, "difuseColor")
                gl.uniform3f(difuseColorUniform, 1.0,0.0, 0.0)
                
                gl.drawElements( gl.LINES, curve_index_buffer.numItems, gl.UNSIGNED_SHORT, 0);
            }
            
            
            function tick(){
                viewMatrix=droneCam.getViewMatrix();

                requestAnimationFrame(tick);
                droneCam.update();
                drawScene();
                //objeto.animate();
            }

            window.onload=initWebGL;

        </script>


    </body>
</html>
