<!doctype html>
<html>
    <head>
        <title></title>        
        <style>
            body{ background-color: grey; }
            canvas{ background-color: rgb(100,100,100); }
			textarea{ background-color: black; foreground-color: white;}
        </style>
    </head>
    <body>

    	<center>    		            
            <canvas id="my-canvas" width="1000" height="800">
            	Your browser does not support the HTML5 canvas element.
    		</canvas>    		
    	</center>

        <script type="text/javascript" src="js/gl-matrix.js"></script>
        <script type="text/javascript" src="js/objeto3D.js"></script>
        <script type="text/javascript" src="js/objeto3DControlable.js"></script>

        <script type="text/javascript" src="js/moduloGeometria.js"></script>
        <script src="js/dat.gui.js"></script>
        <script src="js/jquery.min.js"></script>
        <script type="text/javascript" src="js/scenes.js"></script>

        
        <script id="shader-vs" type="x-shader/x-vertex">
            precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;
            uniform float uTime;

            uniform mat4 modelMatrix;            
            uniform mat4 viewMatrix;
            uniform mat4 projMatrix;

            varying vec3 vNormal;    
            varying vec3 vPosWorld;
            varying float time;


            mat3 transpose(mat3 matrix) {
                vec3 row0 = matrix[0];
                vec3 row1 = matrix[1];
                vec3 row2 = matrix[2];
            
                return mat3(
                    vec3(row0.x, row1.x, row2.x),
                    vec3(row0.y, row1.y, row2.y),
                    vec3(row0.z, row1.z, row2.z));
            }
            
            float det(mat2 matrix) {
                return matrix[0].x * matrix[1].y - matrix[0].y * matrix[1].x;
            }
            
            mat3 inverse(mat3 matrix) {
                vec3 row0 = matrix[0];
                vec3 row1 = matrix[1];
                vec3 row2 = matrix[2];
            
                vec3 minors0 = vec3(
                    det(mat2(row1.y, row1.z, row2.y, row2.z)),
                    det(mat2(row1.z, row1.x, row2.z, row2.x)),
                    det(mat2(row1.x, row1.y, row2.x, row2.y))
                );
                vec3 minors1 = vec3(
                    det(mat2(row2.y, row2.z, row0.y, row0.z)),
                    det(mat2(row2.z, row2.x, row0.z, row0.x)),
                    det(mat2(row2.x, row2.y, row0.x, row0.y))
                );
                vec3 minors2 = vec3(
                    det(mat2(row0.y, row0.z, row1.y, row1.z)),
                    det(mat2(row0.z, row0.x, row1.z, row1.x)),
                    det(mat2(row0.x, row0.y, row1.x, row1.y))
                );
            
                mat3 adj = transpose(mat3(minors0, minors1, minors2));
            
                return (1.0 / dot(row0, minors0)) * adj;
            }

            void main(void) {
                mat4 mvp = projMatrix * viewMatrix * modelMatrix;
                gl_Position =  mvp * vec4(aVertexPosition, 1.0);

                vPosWorld = (mvp * vec4(aVertexPosition, 1.0)).xyz;    //la posicion en coordenadas de mundo
                
                mat3 normalMatrix = mat3(modelMatrix);

                normalMatrix = inverse(normalMatrix);
                normalMatrix = transpose(normalMatrix);
                vNormal = normalize(normalMatrix * aVertexNormal).xyz;//(normalMatrix*vec4(aVertexNormal,1.0)).xyz;       //la normal en coordenadas de mundo                
                time = uTime;
            }
        </script>

        <script id="shader-fs" type="x-shader/x-fragment">
            precision highp float;
            uniform vec3 difuseColor;
            varying vec3 vNormal;
            varying vec3 vPosWorld;

            varying float time;

            void main(void) {
                vec3 light = vec3(100000.0*cos(time * 0.1),100000.0*sin(time * 0.1),0.0);
                vec3 lightVec=normalize(light - vPosWorld);
                vec3 color= max(dot(vNormal,lightVec), 0.0) * difuseColor ;

               gl_FragColor = vec4(color,1.0);
            }
        </script>
        
        <script>
            function Esfera(radio, porcion_fi=Math.PI*2){

                this.getPosicion=function(u,v){
                    var tita = v*Math.PI;
                    var fi = u*porcion_fi
                    var x = radio*Math.sin(tita)*Math.cos(fi)
                    var y = radio*Math.sin(tita)*Math.sin(fi)
                    var z = radio*Math.cos(tita)
                    return [x,y,z];
                }

                this.getNormal=function(u,v){
                    var delta=0.01;
                    var p0=this.getPosicion(u,v);
                    var p1=this.getPosicion(u,v+delta); // tener cuidado si u o v son mayores que 1. En esfera no pasa nada
                    var p2=this.getPosicion(u+delta,v);

                    
                    var v1=vec3.fromValues(p1[0]-p0[0],p1[1]-p0[1],p1[2]-p0[2]);
                    var v2=vec3.fromValues(p2[0]-p0[0],p2[1]-p0[1],p2[2]-p0[2]);

                    vec3.normalize(v1,v1);
                    vec3.normalize(v2,v2);
                    
                    var n=vec3.create();
                    vec3.cross(n,v1,v2);
                    //vec3.scale(n,n,-1);
                    
                    return n                }

                this.getCoordenadasTextura=function(u,v){
                    return [u,v];
                }
            }

            function EsferaRara(radio){
                this.getPosicion= function(u,v){
                    var alfa=v*Math.PI*2;
                    var beta=(0.1+u*0.8)*Math.PI;
                    var r=radio;
                    var nx=Math.sin(beta)*Math.sin(alfa);
                    var ny=Math.sin(beta)*Math.cos(alfa);
                    var nz=Math.cos(beta);


                    var g=beta%0.5;
                    var h=alfa%1;
                    var f=1;

                    if (g<0.25) f=0.95;
                    if (h<0.5) f=f*0.95;

                    var x=nx*r*f;
                    var y=ny*r*f;
                    var z=nz*r*f;

                    return [x,y,z];
                }

                this.getNormal=function(u,v){
                    var delta=0.016;
                    var p1=this.getPosicion(u,v);
                    var p2=this.getPosicion(u,v+delta);
                    var p3=this.getPosicion(u+delta,v);

                    var v1=vec3.fromValues(p2[0]-p1[0],p2[1]-p1[1],p2[2]-p1[2]);
                    var v2=vec3.fromValues(p3[0]-p1[0],p3[1]-p1[1],p3[2]-p1[2]);

                    vec3.normalize(v1,v1);
                    vec3.normalize(v2,v2);
                    
                    var n=vec3.create();
                    vec3.cross(n,v1,v2);
                    vec3.normalize(n,n)
                    return n;
                }

                this.getCoordenadasTextura=function(u,v){
                    return [u,v];
                }
            }

            function CurvaBezier(poligono_control){
                function fact(num)
                {
                    var rval=1;
                    for (var i = 2; i <= num; i++)
                        rval = rval * i;
                    return rval;
                }

                function combinations(n,k) {

                    return (fact(n) / ((fact(k)) * fact(n - k)))
                }

                function B(i,n,t) {
                    /*if ((i == 0) &(t==0)){
                        return (combinations(n,i)*((1-t)**(n-i)) *1)
                    } else if (t==1){
                        return (combinations(n,i)*(1) *(t**i))
                    }*/
                    return (combinations(n,i)*((1-t)**(n-i)) *(t**i))
                }

                this.evaluarPunto= function(t){
                    resultado = vec3.fromValues(0,0,0);
                    n = poligono_control.length;
                    for (i = 0; i< n; i++){
                        var auxvec = vec3.create();
                        vec3.scale(auxvec,poligono_control[i],B(i,n-1,t));

                        vec3.add(resultado,resultado, auxvec);
                    }
                    return resultado;
                }

            }

            
            // crea una circunferencia en el plano xy rotada segun vec_rot
            function CurvaCircunferencia(radio, vec_rot, parametrizacion = Math.PI*2){
                this.evaluarPunto= function(t){

                    position = vec3.fromValues(Math.cos(parametrizacion*t),Math.sin(parametrizacion*t),0)
                    vec3.scale(position, position, radio)
                    vec3.rotateX(position, position, vec3.fromValues(0,0,0), vec_rot[0])
                    vec3.rotateY(position, position, vec3.fromValues(0,0,0), vec_rot[1])
                    vec3.rotateZ(position, position, vec3.fromValues(0,0,0), vec_rot[2])

                    return position;
                }
            }
            
            var mat4=glMatrix.mat4;
            var vec3=glMatrix.vec3;

            var gl = null,
            canvas = null,

            glProgram = null,
            fragmentShader = null,
            vertexShader = null;
                
            var vertexPositionAttribute = null,
            trianglesVerticeBuffer = null,
            vertexNormalAttribute = null,
            trianglesNormalBuffer = null,
            trianglesIndexBuffer = null;
               
            var modelMatrix = mat4.create();
            var viewMatrix = mat4.create();
            var projMatrix = mat4.create();
            var normalMatrix = mat4.create();
            var rotate_angle = -1.57078;


            const MAX_DISTANCIA_VISTA = 15000;
            var factor_fov = 1.0

            var camera = 3;
            var global_t = 0;
            //let droneCam=new DroneCameraControl([-10,7,25]);

            var cantidad_filas_paneles = 4;
            var angulo_paneles = 330;
            var velocidad_rotacion_anillo = 0.1; // vueltas por segundo
            var cantidad_modulos_anillo = 4;

            /*var curva_vista = new ObjetoCurva3D()
            curva_vista.setColor(0,0.5,1);*/


            $('body').on("keydown",function(event){
                switch (event.keyCode) {
                case 0x31:
                    camera = 1; 
                    viewMatrix = obtenerViewMatrixOrbital(camera1,true);
                    break;
                case 0x32:
                    camera = 2; 
                    viewMatrix = obtenerViewMatrixOrbital(camera2,true);
                    break;
                case 0x33:
                    camera = 3; 
                    viewMatrix = obtenerViewMatrix(camera3);

                    break;
                }
                    
            });
            
            $('body').on("wheel",function(event, delta){
                switch (event.originalEvent.wheelDelta >= 0) {
                case true:
                    if (factor_fov >= 0.98){
                        factor_fov-=0.001; 
                        updateProjMatrix();
                    }
                    break;
                case false:
                    if (factor_fov <= 1.02){
                        factor_fov+=0.001; 
                        updateProjMatrix();
                        break;
                    }
                }
                    
            });  
            function initWebGL(){

                canvas = document.getElementById("my-canvas");  
                //init orbital mouse control
                $(canvas).mousemove(function(e){ 
                    mouse.x = e.clientX || e.pageX; 
                    mouse.y = e.clientY || e.pageY 
                });
                
                $(canvas).mousedown(function(event){		
                    isMouseDown = true;        
                });

                $(canvas).mouseup(function(event){
                    isMouseDown = false;		
                });
                //

                try{
                    gl = canvas.getContext("webgl");      

                }catch(e){
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

                if(gl) {

                    setupWebGL();
                    initShaders();
                    objeto_principal = mainScene()
                    //objeto_principal.agregarHijo(curva_vista)
                    
                    setupVertexShaderMatrix();
                    initMenu();

                    tick();   
                    

                }else{    
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

            }
           

            function setupWebGL(){
                gl.enable(gl.DEPTH_TEST);
                //set the clear color
                gl.clearColor(0.1, 0.1, 0.2, 1.0);     
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);     
    
                gl.viewport(0, 0, canvas.width, canvas.height);

                // Matrix de Proyeccion Perspectiva
                updateProjMatrix()
                
                mat4.identity(modelMatrix);
                mat4.rotate(modelMatrix,modelMatrix, -1.57078, [1.0, 0.0, 0.0]);

                mat4.identity(viewMatrix);
                mat4.translate(viewMatrix,viewMatrix, [0.0, 0.0, -5.0]);
            }
                    
            function updateProjMatrix(){
                mat4.perspective(projMatrix,factor_fov*45, canvas.width / canvas.height, 0.1, MAX_DISTANCIA_VISTA);
            }
                    
            function initShaders() {
                //get shader source
                var fs_source = document.getElementById('shader-fs').innerHTML,
                    vs_source = document.getElementById('shader-vs').innerHTML;

                //compile shaders    
                vertexShader = makeShader(vs_source, gl.VERTEX_SHADER);
                fragmentShader = makeShader(fs_source, gl.FRAGMENT_SHADER);
                
                //create program
                glProgram = gl.createProgram();
                
                //attach and link shaders to the program
                gl.attachShader(glProgram, vertexShader);
                gl.attachShader(glProgram, fragmentShader);
                gl.linkProgram(glProgram);

                if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
                    alert("Unable to initialize the shader program.");
                }
                
                //use program
                gl.useProgram(glProgram);
            }
            
            function makeShader(src, type){
                //compile the vertex shader
                var shader = gl.createShader(type);
                gl.shaderSource(shader, src);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.log("Error compiling shader: " + gl.getShaderInfoLog(shader));
                }
                return shader;
            }


            function setupVertexShaderMatrix(){
                var viewMatrixUniform  = gl.getUniformLocation(glProgram, "viewMatrix");
                var projMatrixUniform  = gl.getUniformLocation(glProgram, "projMatrix");
                var normalMatrixUniform  = gl.getUniformLocation(glProgram, "normalMatrix");

                gl.uniformMatrix4fv(viewMatrixUniform, false, viewMatrix);
                gl.uniformMatrix4fv(projMatrixUniform, false, projMatrix);
                gl.uniformMatrix4fv(normalMatrixUniform, false, normalMatrix);
            }      
            
            function drawScene(){
                setupVertexShaderMatrix();

                matPadre= mat4.create() // matriz identidad para nodo principal

                objeto_principal.dibujar(matPadre);                
            }
            
            
            function tick(){
                requestAnimationFrame(tick);
                if (camera == 1) {
                    cameraactual = camera1;
                    viewMatrix = obtenerViewMatrixOrbital(cameraactual,isMouseDown);
                }
                else if (camera == 2) {
                    cameraactual = camera2;
                    viewMatrix = obtenerViewMatrixOrbital(cameraactual,isMouseDown);
                }
                else if (camera == 3) {
                    cameraactual = camera3;
                    viewMatrix = obtenerViewMatrix(cameraactual);
                    //viewMatrix=droneCam.getViewMatrix();
                }

                drawScene();

                global_t+=0.1
            }
            // orbital


            // manejo de mouse y teclado
            var previousClientX = 0;
            var previousClientY = 0;
            var radio = 5;
            var alfa = 0;
            var beta = Math.PI/2;
            var factorVelocidad = 0.01;

            var isMouseDown = false;
            var actualEvent;

            var mouse = {x: 0, y: 0};

            function obtenerViewMatrixOrbital(o_camara, updateAngle)
            {   
                if (updateAngle == true){
                    var deltaX=0;
                    var deltaY=0;
                    if (previousClientX) deltaX = previousClientX - mouse.x;
                    if (previousClientY) deltaY = mouse.y - previousClientY;

                    previousClientX = mouse.x;
                    previousClientY = mouse.y;

                    alfa = alfa + deltaX * factorVelocidad;
                    beta = beta + deltaY * factorVelocidad;

                    if (beta<=0) beta=0.001;
                    if (beta>=Math.PI) beta=Math.PI*0.999;
                }

                var mat = o_camara.getMatTransformations();
                var vec_position = vec3.create();
                mat4.getTranslation(vec_position,mat);

                var vec_direccion = vec3.fromValues(radio * Math.cos(alfa) * Math.sin(beta) ,radio * Math.sin(alfa) * Math.sin(beta), radio * Math.cos(beta));	
                vec3.transformMat4(vec_direccion, vec_direccion, mat)

                var vec3upvector = vec3.fromValues(0,0,1)
                vec3.transformMat4(vec3upvector, vec3upvector, mat)
                vec3.sub(vec3upvector,vec3upvector,vec_position)
                //

                var result = mat4.create()
                mat4.lookAt(result, vec_position, vec_direccion, vec3upvector)

                //setear curva vista:
                /*vec3.add(vec3upvector,vec3upvector,vec_position)

                vista_pos_buffer = [vec_position[0],vec_position[1],vec_position[2],vec_direccion[0],vec_direccion[1],vec_direccion[2],vec_position[0],vec_position[1],vec_position[2],vec3upvector[0],vec3upvector[1],vec3upvector[2]]
                console.log(vista_pos_buffer)
                var webgl_position_buffer = gl.createBuffer();
                webgl_position_buffer.itemSize = 3;
                gl.bindBuffer(gl.ARRAY_BUFFER, webgl_position_buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vista_pos_buffer), gl.STATIC_DRAW);

                vista_nm_buffer = [1,1,1,1,1,1,1,1,1,1,1,1]
                var webgl_normal_buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, webgl_normal_buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vista_nm_buffer), gl.STATIC_DRAW);
                webgl_normal_buffer.itemSize = 3;

                vista_idx_buffer = [0,1,2,3]
                var vidxbuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vidxbuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vista_idx_buffer), gl.STATIC_DRAW);
                vidxbuffer.itemSize = 1;
                vidxbuffer.numItems = 4;

                curva_vista.setGeometria({webgl_position_buffer,webgl_normal_buffer}, vidxbuffer)
                //*/
                return result
            }

            function obtenerViewMatrix(o_camara)
            {   
                var mat = o_camara.getMatTransformations();
                var vec_position = vec3.create();
                mat4.getTranslation(vec_position,mat);

                var vec_direccion = vec3.fromValues(0,0,10);	
                vec3.transformMat4(vec_direccion, vec_direccion, mat)

                var vec3upvector = vec3.fromValues(0,-1,0)
                vec3.transformMat4(vec3upvector, vec3upvector, mat)
                vec3.sub(vec3upvector,vec3upvector,vec_position)
                //

                var result = mat4.create()
                mat4.lookAt(result, vec_position, vec_direccion, vec3upvector)
                return result
            }
    //

            function initMenu(){
                var gui = new dat.GUI();
                
                const reconstruirFolder = gui.addFolder('Para reconstruir forma:')
                reconstruirFolder.add(window, "cantidad_filas_paneles",1,10).step(1);
                reconstruirFolder.add(window, "angulo_paneles",0,360).step(5);
                reconstruirFolder.add(window, "velocidad_rotacion_anillo",0,1).step(0.05);
                reconstruirFolder.add(window, "cantidad_modulos_anillo",2,8).step(1);

                var obj = { reconstruir:function(){ objeto_principal = mainScene(); }};

                reconstruirFolder.add(obj,'reconstruir');
                reconstruirFolder.open()
                
            }
            window.onload=initWebGL;

        </script>


    </body>
</html>
